import * as React from 'react';
import {
  GridFooterNode,
  GridGroupNode,
  GridRowId,
  GridRowIdGetter,
  GridRowModel,
  GridRowModelUpdate,
  GridRowTreeConfig,
  GridTreeNode,
} from '../../../models';
import { DataGridProcessedProps } from '../../../models/props/DataGridProps';
import { GridApiCommunity } from '../../../models/api/gridApiCommunity';
import {
  GridRowsFullUpdate,
  GridRowsInternalCache,
  GridRowsPartialUpdates,
  GridRowsState,
  GridRowTreeCreationParams,
  GridRowIdToModelLookup,
  GridRowIdToIdLookup,
  GridRowsPartialUpdateAction,
} from './gridRowsInterfaces';

export const GRID_ROOT_GROUP_ID: GridRowId = `auto-generated-group-node-root`;

export const buildRootGroup = (): GridGroupNode => ({
  type: 'group',
  id: GRID_ROOT_GROUP_ID,
  depth: -1,
  groupingField: null,
  groupingKey: null,
  isAutoGenerated: true,
  children: [],
  childrenFromPath: {},
  childrenExpanded: true,
  parent: null,
});

/**
 * A helper function to check if the id provided is valid.
 * @param {GridRowId} id Id as [[GridRowId]].
 * @param {GridRowModel | Partial<GridRowModel>} row Row as [[GridRowModel]].
 * @param {string} detailErrorMessage A custom error message to display for invalid IDs
 */
export function checkGridRowIdIsValid(
  id: GridRowId,
  row: GridRowModel | Partial<GridRowModel>,
  detailErrorMessage: string = 'A row was provided without id in the rows prop:',
) {
  if (id == null) {
    throw new Error(
      [
        'MUI: The data grid component requires all rows to have a unique `id` property.',
        'Alternatively, you can use the `getRowId` prop to specify a custom id for each row.',
        detailErrorMessage,
        JSON.stringify(row),
      ].join('\n'),
    );
  }
}

export const getRowIdFromRowModel = (
  rowModel: GridRowModel,
  getRowId?: GridRowIdGetter,
  detailErrorMessage?: string,
): GridRowId => {
  const id = getRowId ? getRowId(rowModel) : rowModel.id;
  checkGridRowIdIsValid(id, rowModel, detailErrorMessage);
  return id;
};

export const getEmptyRowPartialUpdate = (): GridRowsPartialUpdates => ({
  type: 'partial',
  actions: {
    insert: [],
    modify: [],
    remove: [],
  },
  idToActionLookup: {},
});

export const createRowsInternalCache = ({
  rows,
  getRowId,
  loading,
}: Pick<DataGridProcessedProps, 'rows' | 'getRowId' | 'loading'>): GridRowsInternalCache => {
  const updates: GridRowsFullUpdate = {
    type: 'full',
    rows: [],
  };

  const dataRowIdToModelLookup: GridRowIdToModelLookup = {};
  const dataRowIdToIdLookup: GridRowIdToIdLookup = {};

  for (let i = 0; i < rows.length; i += 1) {
    const model = rows[i];
    const id = getRowIdFromRowModel(model, getRowId);
    dataRowIdToModelLookup[id] = model;
    dataRowIdToIdLookup[id] = id;
    updates.rows.push(id);
  }

  return {
    rowsBeforePartialUpdates: rows,
    loadingPropBeforePartialUpdates: loading,
    updates,
    dataRowIdToIdLookup,
    dataRowIdToModelLookup,
  };
};

export const getRowsStateFromCache = ({
  apiRef,
  rowCountProp,
  loadingProp,
  previousTree,
  previousTreeDepths,
}: Pick<GridRowTreeCreationParams, 'previousTree' | 'previousTreeDepths'> & {
  apiRef: React.MutableRefObject<GridApiCommunity>;
  rowCountProp: number | undefined;
  loadingProp: boolean | undefined;
}): GridRowsState => {
  const cache = apiRef.current.unstable_caches.rows;
  const rowCount = rowCountProp ?? 0;

  const groupingResponse = apiRef.current.unstable_applyStrategyProcessor('rowTreeCreation', {
    previousTree,
    previousTreeDepths,
    updates: cache.updates,
    dataRowIdToIdLookup: cache.dataRowIdToIdLookup,
    dataRowIdToModelLookup: cache.dataRowIdToModelLookup,
  });

  const processingResponse = apiRef.current.unstable_applyPipeProcessors(
    'hydrateRows',
    groupingResponse,
  );

  const rootGroupNode = processingResponse.tree[GRID_ROOT_GROUP_ID] as GridGroupNode;

  apiRef.current.unstable_caches.rows = {
    ...apiRef.current.unstable_caches.rows,
    updates: getEmptyRowPartialUpdate(),
  };

  return {
    groupingName: groupingResponse.groupingName,
    dataRowIds: groupingResponse.dataRowIds,
    tree: processingResponse.tree,
    treeDepths: processingResponse.treeDepths,
    loading: loadingProp,
    totalRowCount: Math.max(rowCount, groupingResponse.dataRowIds.length),
    totalTopLevelRowCount: Math.max(
      rowCount,
      rootGroupNode.children.length + (rootGroupNode.footerId == null ? 0 : 1),
    ),
    dataRowIdToIdLookup: cache.dataRowIdToIdLookup,
    dataRowIdToModelLookup: cache.dataRowIdToModelLookup,
  };
};

export const getTreeNodeDescendants = (
  tree: GridRowTreeConfig,
  parentId: GridRowId,
  skipAutoGeneratedRows: boolean,
) => {
  const node = tree[parentId];
  if (node.type !== 'group') {
    return [];
  }

  const validDescendants: GridRowId[] = [];
  for (let i = 0; i < node.children.length; i += 1) {
    const child = node.children[i];
    const childNode = tree[child];
    if (
      !skipAutoGeneratedRows ||
      childNode.type === 'leaf' ||
      (childNode.type === 'group' && !childNode.isAutoGenerated)
    ) {
      validDescendants.push(child);
    }
    validDescendants.push(...getTreeNodeDescendants(tree, childNode.id, skipAutoGeneratedRows));
  }

  if (!skipAutoGeneratedRows && node.footerId != null) {
    validDescendants.push(node.footerId);
  }

  return validDescendants;
};

export const isAutoGeneratedRow = (
  rowNode: GridTreeNode,
): rowNode is GridGroupNode | GridFooterNode =>
  rowNode.type === 'footer' || (rowNode.type === 'group' && rowNode.isAutoGenerated);

export const updateCacheWithNewRows = ({
  previousCache,
  getRowId,
  updates,
}: {
  previousCache: GridRowsInternalCache;
  getRowId: DataGridProcessedProps['getRowId'];
  updates: GridRowModelUpdate[];
}): GridRowsInternalCache => {
  if (previousCache.updates.type === 'full') {
    throw new Error('MUI: Unable to prepare a partial update if a full update is not applied yet');
  }

  // we remove duplicate updates. A server can batch updates, and send several updates for the same row in one fn call.
  const uniqUpdates = new Map<GridRowId, GridRowModel>();

  updates.forEach((update) => {
    const id = getRowIdFromRowModel(
      update,
      getRowId,
      'A row was provided without id when calling updateRows():',
    );

    if (uniqUpdates.has(id)) {
      uniqUpdates.set(id, { ...uniqUpdates.get(id), ...update });
    } else {
      uniqUpdates.set(id, update);
    }
  });

  const deletedRowIdLookup: Record<GridRowId, true> = {};

  const partialUpdates: GridRowsPartialUpdates = {
    type: 'partial',
    actions: {
      insert: [...(previousCache.updates.actions.insert ?? [])],
      modify: [...(previousCache.updates.actions.modify ?? [])],
      remove: [...(previousCache.updates.actions.remove ?? [])],
    },
    idToActionLookup: { ...previousCache.updates.idToActionLookup },
  };
  const dataRowIdToModelLookup = { ...previousCache.dataRowIdToModelLookup };
  const dataRowIdToIdLookup = { ...previousCache.dataRowIdToIdLookup };

  const alreadyAppliedActionsToRemove: {
    [action in GridRowsPartialUpdateAction]: { [id: GridRowId]: true };
  } = { insert: {}, modify: {}, remove: {} };

  uniqUpdates.forEach((partialRow, id) => {
    const actionAlreadyAppliedToRow = partialUpdates.idToActionLookup[id];

    // eslint-disable-next-line no-underscore-dangle
    if (partialRow._action === 'delete') {
      // Action === "delete"
      if (actionAlreadyAppliedToRow === 'remove' || !dataRowIdToModelLookup[id]) {
        return;
      }
      if (actionAlreadyAppliedToRow != null) {
        alreadyAppliedActionsToRemove[actionAlreadyAppliedToRow][id] = true;
      }
      partialUpdates.actions.remove.push(id);

      deletedRowIdLookup[id] = true;
      delete dataRowIdToModelLookup[id];
      delete dataRowIdToIdLookup[id];
      return;
    }

    const oldRow = dataRowIdToModelLookup[id];
    if (oldRow) {
      // Action === "modify"
      if (actionAlreadyAppliedToRow === 'remove') {
        alreadyAppliedActionsToRemove.remove[id] = true;
        partialUpdates.actions.modify.push(id);
      } else if (actionAlreadyAppliedToRow == null) {
        partialUpdates.actions.modify.push(id);
      }

      dataRowIdToModelLookup[id] = { ...oldRow, ...partialRow };
      return;
    }

    // Action === "insert"
    if (actionAlreadyAppliedToRow === 'remove') {
      alreadyAppliedActionsToRemove.remove[id] = true;
      partialUpdates.actions.insert.push(id);
    } else if (actionAlreadyAppliedToRow == null) {
      partialUpdates.actions.insert.push(id);
    }

    dataRowIdToModelLookup[id] = partialRow;
    dataRowIdToIdLookup[id] = id;
  });

  Object.entries(alreadyAppliedActionsToRemove).forEach(([action, idsToRemove]) => {
    if (Object.keys(idsToRemove).length > 0) {
      partialUpdates.actions[action as GridRowsPartialUpdateAction] = partialUpdates.actions[
        action as GridRowsPartialUpdateAction
      ].filter((id) => !idsToRemove[id]);
    }
  });

  return {
    dataRowIdToModelLookup,
    dataRowIdToIdLookup,
    updates: partialUpdates,
    rowsBeforePartialUpdates: previousCache.rowsBeforePartialUpdates,
    loadingPropBeforePartialUpdates: previousCache.loadingPropBeforePartialUpdates,
  };
};
