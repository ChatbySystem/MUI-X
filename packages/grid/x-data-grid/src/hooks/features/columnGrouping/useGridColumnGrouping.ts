import * as React from 'react';
import { GridApiCommunity } from '../../../models/api/gridApiCommunity';
import { DataGridProcessedProps } from '../../../models/props/DataGridProps';
import { GridStateInitializer } from '../../utils/useGridInitializeState';
import {
  GridColumnNode,
  isLeaf,
} from '../../../models/gridColumnGrouping';
import { gridColumnGroupsLookupSelector } from './gridColumnGroupsSelector';
import { gridColumnLookupSelector } from '../columns/gridColumnsSelector';
import { GridColumnGroupLookup } from './gridColumnGroupsInterfaces';
import { GridColumnGroupingApi } from '../../../models/api/gridColumnGroupingApi';
import { useGridApiMethod } from '../../utils/useGridApiMethod';

const createGroupLookup = (columnGroupingModel: GridColumnNode[]): GridColumnGroupLookup => {
  let groupLookup: GridColumnGroupLookup = {};

  columnGroupingModel.forEach((node) => {
    if (isLeaf(node)) {
      return;
    }
    const { groupId, children, ...other } = node;
    if (!groupId) {
      throw new Error(
        'MUI: An element of the columnGroupingModel does not have either `field` or `groupId`.',
      );
    }
    if (!children) {
      console.warn(`MUI: group groupId=${groupId} has no children.`);
    }
    const groupParam = { ...other, groupId };
    const subTreeLookup = createGroupLookup(children);
    if (subTreeLookup[groupId] !== undefined || groupLookup[groupId] !== undefined) {
      throw new Error(
        `MUI: The groupId ${groupId} is used multiple times in the columnGroupingModel.`,
      );
    }
    groupLookup = { ...groupLookup, ...subTreeLookup, [groupId]: groupParam };
  });

  return { ...groupLookup };
};
export const columnGroupsStateInitializer: GridStateInitializer<
  Pick<DataGridProcessedProps, 'columnGroupingModel'>
> = (state, props) => {
  const groupLookup = createGroupLookup(props.columnGroupingModel ?? []);
  return {
    ...state,
    columnGrouping: { lookup: groupLookup, groupCollapsedModel: {} },
  };
};

/**
 * @requires useGridColumns (method, event)
 * @requires useGridParamsApi (method)
 */
export const useGridColumnGrouping = (
  apiRef: React.MutableRefObject<GridApiCommunity>,
  props: Pick<DataGridProcessedProps, 'columnGroupingModel' | 'experimentalFeatures'>,
) => {
  /**
   * API METHODS
   */
  const getColumnGroupPath = React.useCallback<
    GridColumnGroupingApi['unstable_getColumnGroupPath']
  >(
    (field) => {
      const columnLookup = gridColumnLookupSelector(apiRef);

      return columnLookup[field]?.groupPath ?? [];
    },
    [apiRef],
  );

  const getAllGroupDetails = React.useCallback<
    GridColumnGroupingApi['unstable_getAllGroupDetails']
  >(() => {
    const columnGroupLookup = gridColumnGroupsLookupSelector(apiRef);
    return columnGroupLookup;
  }, [apiRef]);

  const columnGroupingApi: GridColumnGroupingApi = {
    unstable_getColumnGroupPath: getColumnGroupPath,
    unstable_getAllGroupDetails: getAllGroupDetails,
  };

  useGridApiMethod(apiRef, columnGroupingApi, 'GridColumnGroupingApi');

  /**
   * EFFECTS
   */
  // The effect does not track any value defined synchronously during the 1st render by hooks called after `useGridColumns`
  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one
  const isFirstRender = React.useRef(true);
  React.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }
    if (!props.experimentalFeatures?.columnGrouping) {
      return;
    }
    const groupLookup = createGroupLookup(props.columnGroupingModel ?? []);
    apiRef.current.setState((state) => ({
      ...state,
      columnGrouping: { ...state.columnGrouping, lookup: groupLookup },
    }));
  }, [apiRef, props.columnGroupingModel, props.experimentalFeatures?.columnGrouping]);
};
