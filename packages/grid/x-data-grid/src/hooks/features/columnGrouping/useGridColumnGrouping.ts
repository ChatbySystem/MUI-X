import * as React from 'react';
import { GridApiCommunity } from '../../../models/api/gridApiCommunity';
import { DataGridProcessedProps } from '../../../models/props/DataGridProps';
import { GridStateInitializer } from '../../utils/useGridInitializeState';
import { GridColumnNode, isLeaf } from '../../../models/gridColumnGrouping';
import {
  gridColumnGroupsLookupSelector,
  gridColumnGroupsUnwrappedModelSelector,
} from './gridColumnGroupsSelector';
import { GridColumnGroupLookup } from './gridColumnGroupsInterfaces';
import { GridColumnGroupingApi } from '../../../models/api/gridColumnGroupingApi';
import { useGridApiMethod } from '../../utils/useGridApiMethod';
import { getColumnGroupsHeaderStructure, unwrapGroupingColumnModel } from './gridColumnGroupsUtils';
import { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';
import { GridEventListener } from '../../../models/events';

const createGroupLookup = (columnGroupingModel: GridColumnNode[]): GridColumnGroupLookup => {
  let groupLookup: GridColumnGroupLookup = {};

  columnGroupingModel.forEach((node) => {
    if (isLeaf(node)) {
      return;
    }
    const { groupId, children, ...other } = node;
    if (!groupId) {
      throw new Error(
        'MUI: An element of the columnGroupingModel does not have either `field` or `groupId`.',
      );
    }
    if (!children) {
      console.warn(`MUI: group groupId=${groupId} has no children.`);
    }
    const groupParam = { ...other, groupId };
    const subTreeLookup = createGroupLookup(children);
    if (subTreeLookup[groupId] !== undefined || groupLookup[groupId] !== undefined) {
      throw new Error(
        `MUI: The groupId ${groupId} is used multiple times in the columnGroupingModel.`,
      );
    }
    groupLookup = { ...groupLookup, ...subTreeLookup, [groupId]: groupParam };
  });

  return { ...groupLookup };
};

export const columnGroupsStateInitializer: GridStateInitializer<
  Pick<DataGridProcessedProps, 'columnGroupingModel'>
> = (state, props) => {
  const groupLookup = createGroupLookup(props.columnGroupingModel ?? []);
  const unwrappedGroupingModel = unwrapGroupingColumnModel(props.columnGroupingModel ?? []);

  const orderedFields = state.columns?.all ?? [];

  const columnGroupsHeaderStructure = getColumnGroupsHeaderStructure(
    orderedFields as string[],
    unwrappedGroupingModel,
  );
  return {
    ...state,
    columnGrouping: {
      lookup: groupLookup,
      groupCollapsedModel: {},
      unwrappedGroupingModel,
      headerStructure: columnGroupsHeaderStructure,
    },
  };
};

/**
 * @requires useGridColumns (method, event)
 * @requires useGridParamsApi (method)
 */
export const useGridColumnGrouping = (
  apiRef: React.MutableRefObject<GridApiCommunity>,
  props: Pick<DataGridProcessedProps, 'columnGroupingModel' | 'experimentalFeatures'>,
) => {
  /**
   * API METHODS
   */
  const getColumnGroupPath = React.useCallback<
    GridColumnGroupingApi['unstable_getColumnGroupPath']
  >(
    (field) => {
      const unwrappedGroupingModel = gridColumnGroupsUnwrappedModelSelector(apiRef);

      return unwrappedGroupingModel[field] ?? [];
    },
    [apiRef],
  );

  const getAllGroupDetails = React.useCallback<
    GridColumnGroupingApi['unstable_getAllGroupDetails']
  >(() => {
    const columnGroupLookup = gridColumnGroupsLookupSelector(apiRef);
    return columnGroupLookup;
  }, [apiRef]);

  const columnGroupingApi: GridColumnGroupingApi = {
    unstable_getColumnGroupPath: getColumnGroupPath,
    unstable_getAllGroupDetails: getAllGroupDetails,
  };

  useGridApiMethod(apiRef, columnGroupingApi, 'GridColumnGroupingApi');

  const handleColumnReorderChange = React.useCallback<
    GridEventListener<'columnOrderChange'>
  >(() => {
    const unwrappedGroupingModel = unwrapGroupingColumnModel(props.columnGroupingModel ?? []);

    apiRef.current.setState((state) => {
      const orderedFields = state.columns?.all ?? [];

      const columnGroupsHeaderStructure = getColumnGroupsHeaderStructure(
        orderedFields as string[],
        unwrappedGroupingModel,
      );
      return {
        ...state,
        columnGrouping: {
          ...state.columnGrouping,
          headerStructure: columnGroupsHeaderStructure,
        },
      };
    });
  }, [apiRef, props.columnGroupingModel]);

  useGridApiEventHandler(apiRef, 'columnOrderChange', handleColumnReorderChange);
  /**
   * EFFECTS
   */
  // The effect does not track any value defined synchronously during the 1st render by hooks called after `useGridColumns`
  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one
  const isFirstRender = React.useRef(true);
  React.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }
    if (!props.experimentalFeatures?.columnGrouping) {
      return;
    }
    const groupLookup = createGroupLookup(props.columnGroupingModel ?? []);
    const unwrappedGroupingModel = unwrapGroupingColumnModel(props.columnGroupingModel ?? []);

    apiRef.current.setState((state) => {
      const orderedFields = state.columns?.all ?? [];

      const columnGroupsHeaderStructure = getColumnGroupsHeaderStructure(
        orderedFields as string[],
        unwrappedGroupingModel,
      );
      return {
        ...state,
        columnGrouping: {
          lookup: groupLookup,
          // groupCollapsedModel: {},
          unwrappedGroupingModel,
          headerStructure: columnGroupsHeaderStructure,
        },
      };
    });
  }, [apiRef, props.columnGroupingModel, props.experimentalFeatures?.columnGrouping]);
};
