import {
  GridRowId,
  GridRowTreeConfig,
  GridKeyValue,
  GridFooterNode,
  GridLeafNode,
  GridGroupNode,
  GridTreeNode,
  GRID_ROOT_GROUP_ID,
} from '@mui/x-data-grid';
import { GridRowTreeCreationParams, GridRowTreeCreationValue } from '@mui/x-data-grid/internals';

type GridGroupingCriteriaToIdTree = {
  [field: string]: {
    [key: string]: { id: GridRowId; children: GridGroupingCriteriaToIdTree };
  };
};

export interface BuildRowTreeGroupingCriteria {
  field: string | null;
  key: GridKeyValue;
}

interface BuildRowTreeParams extends GridRowTreeCreationParams {
  rows: { id: GridRowId; path: BuildRowTreeGroupingCriteria[] }[];
  defaultGroupingExpansionDepth: number;
  isGroupExpandedByDefault?: (node: TempGridGroupNode) => boolean;
  groupingName: string;
  onDuplicatePath?: (
    firstId: GridRowId,
    secondId: GridRowId,
    path: BuildRowTreeGroupingCriteria[],
  ) => void;
}

export interface TempGridGroupNode extends Omit<GridGroupNode, 'children' | 'childrenExpanded'> {
  children: Record<GridRowId, GridRowId>;
}

type TempGridTreeNode = GridLeafNode | GridFooterNode | TempGridGroupNode;

export const getGroupRowIdFromPath = (path: BuildRowTreeGroupingCriteria[]) => {
  const pathStr = path
    .map((groupingCriteria) => `${groupingCriteria.field}/${groupingCriteria.key}`)
    .join('-');

  return `auto-generated-row-${pathStr}`;
};

/**
 * Transform a list of rows into a tree structure where each row references its parent and children.
 * If a row have a parent which does not exist in the input rows, creates an auto generated row
 *
 ```
 params = {
   ids: [0, 1, 2],
   idRowsLookup: { 0: {...}, 1: {...}, 2: {...} },
   rows: [
     { id: 0, path: ['A'] },
     { id: 1, path: ['B', 'A'] },
     { id: 2, path: ['B', 'A', 'A'] }
   ],
   defaultGroupingExpansionDepth: 0,
 }
 Returns:
 {
   ids: [0, 1, 2, 'auto-generated-row-B'],
   idRowsLookup: { 0: {...}, 1: {...}, 2: {...}, 'auto-generated-row-B': {} },
   tree: {
     '0': { id: 0, parent: null, childrenExpanded: false, depth: 0, groupingKey: 'A' },
     'auto-generated-row-B': { id: 'auto-generated-row-B', parent: null, childrenExpanded: false, depth: 0, groupingKey: 'B' },
     '1': { id: 1, parent: 'auto-generated-row-B', childrenExpanded: false, depth: 1, groupingKey: 'A' },
     '2': { id: 2, parent: 1, childrenExpanded: false, depth: 2, groupingKey: 'A' },
   },
   treeDepth: 3,
 }
 ```
 */
export const buildRowTree = (params: BuildRowTreeParams): GridRowTreeCreationValue => {
  const gridRootGroupNode: TempGridGroupNode = {
    type: 'group',
    id: GRID_ROOT_GROUP_ID,
    depth: -1,
    groupingField: null,
    groupingKey: null,
    isAutoGenerated: true,
    children: {},
    parent: null,
  };

  // During the build, we store the children as a Record to avoid linear complexity when checking if a children is already defined.
  const tempTree: Record<GridRowId, TempGridTreeNode> = {
    [GRID_ROOT_GROUP_ID]: gridRootGroupNode,
  };
  let treeDepth = 1;

  const ids = [...params.ids];
  const idRowsLookup = { ...params.idRowsLookup };
  const idToIdLookup = { ...params.idToIdLookup };

  const groupingCriteriaToIdTree: GridGroupingCriteriaToIdTree = {};

  const isGroupExpandedByDefault = (node: TempGridGroupNode) => {
    if (node.id === GRID_ROOT_GROUP_ID) {
      return true;
    }

    const previousNode = params.previousTree?.[node.id];
    if (previousNode?.type === 'group') {
      return previousNode.childrenExpanded;
    }

    if (Object.keys(node.children).length === 0) {
      return false;
    }

    if (params.isGroupExpandedByDefault) {
      return params.isGroupExpandedByDefault(node);
    }

    return (
      params.defaultGroupingExpansionDepth === -1 ||
      params.defaultGroupingExpansionDepth > node.depth
    );
  };

  for (let i = 0; i < params.rows.length; i += 1) {
    const row = params.rows[i];
    let keyToIdSubTree = groupingCriteriaToIdTree;
    let parentNode: TempGridGroupNode = gridRootGroupNode;

    for (let depth = 0; depth < row.path.length; depth += 1) {
      const { key, field: rawField } = row.path[depth];
      const field = rawField ?? '__no_field__';

      let nodeId: GridRowId;

      let fieldSubTree = keyToIdSubTree[field];
      if (!fieldSubTree) {
        fieldSubTree = {};
        keyToIdSubTree[field] = fieldSubTree;
      }

      let keyConfig = fieldSubTree[key.toString()];

      if (keyConfig) {
        if (depth === row.path.length - 1) {
          params.onDuplicatePath?.(keyConfig.id, row.id, row.path);
        }
        nodeId = keyConfig.id;
      } else {
        if (depth === row.path.length - 1) {
          nodeId = row.id;
        } else {
          nodeId = getGroupRowIdFromPath(row.path.slice(0, depth + 1));
        }

        keyConfig = { id: nodeId, children: {} };
        fieldSubTree[key.toString()] = keyConfig;
      }
      keyToIdSubTree = keyConfig.children;

      parentNode.children[nodeId] = nodeId;

      if (depth < row.path.length - 1) {
        const currentGroupNode = tempTree[nodeId];
        // If the group node does not exist, we create it
        if (!currentGroupNode) {
          idRowsLookup[nodeId] = {};
          ids.push(nodeId);

          const groupNode: TempGridGroupNode = {
            type: 'group',
            id: nodeId,
            depth,
            isAutoGenerated: true,
            groupingKey: key,
            groupingField: rawField,
            children: {},
            parent: parentNode.id,
          };

          tempTree[nodeId] = groupNode;
          parentNode = groupNode;
        }
        // If the group node exists but is of not a group, we turn it into a group
        else if (currentGroupNode.type !== 'group') {
          const groupNode: TempGridGroupNode = {
            type: 'group',
            id: currentGroupNode.id,
            depth: currentGroupNode.depth,
            parent: currentGroupNode.parent,
            isAutoGenerated: false,
            groupingKey: key,
            groupingField: rawField,
            children: {},
          };

          tempTree[nodeId] = groupNode;
          parentNode = groupNode;
        } else {
          parentNode = currentGroupNode;
        }
      } else {
        tempTree[nodeId] = {
          type: 'leaf',
          id: nodeId,
          depth,
          parent: parentNode.id,
          groupingKey: key,
        };
      }
    }

    treeDepth = Math.max(treeDepth, row.path.length);
  }

  const tree: GridRowTreeConfig = {};

  // TODO: Remove the `previousNode` logic once we stop regenerating the whole tree on every update
  const postProcessNode = (tempNode: TempGridTreeNode) => {
    let node: GridTreeNode;
    const previousNode = params.previousTree?.[tempNode.id];

    if (tempNode.type === 'footer' || tempNode.type === 'leaf') {
      if (
        previousNode?.type === tempNode.type &&
        previousNode.depth === tempNode.depth &&
        previousNode.parent === tempNode.parent
      ) {
        node = previousNode;
      } else {
        node = { ...tempNode, parent: tempNode.parent };
      }
    } else {
      const childrenExpanded = isGroupExpandedByDefault(tempNode);
      const groupNode: GridGroupNode = {
        ...tempNode,
        parent: tempNode.parent ?? null,
        childrenExpanded,
        children: Object.values(tempNode.children),
      };

      if (
        previousNode?.type === 'group' &&
        previousNode.depth === groupNode.depth &&
        previousNode.parent === groupNode.parent &&
        previousNode.isAutoGenerated === groupNode.isAutoGenerated &&
        previousNode.parent === groupNode.parent &&
        previousNode.groupingKey === groupNode.groupingKey &&
        previousNode.groupingField === groupNode.groupingField &&
        previousNode.childrenExpanded === groupNode.childrenExpanded &&
        previousNode.children.length === groupNode.children?.length &&
        previousNode.children.every((childNode, index) => groupNode.children?.[index] === childNode)
      ) {
        node = previousNode;
      } else {
        node = groupNode;
      }
    }

    tree[node.id] = node;
  };

  postProcessNode(gridRootGroupNode);

  for (let i = 0; i < ids.length; i += 1) {
    postProcessNode(tempTree[ids[i]]);
  }

  return {
    tree,
    treeDepth,
    ids,
    idRowsLookup,
    idToIdLookup,
    groupingName: params.groupingName,
  };
};
