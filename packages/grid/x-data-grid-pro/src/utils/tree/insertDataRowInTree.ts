import {
  GRID_ROOT_GROUP_ID,
  GridGroupNode,
  GridKeyValue,
  GridRowId,
  GridTreeNode,
} from '@mui/x-data-grid';
import { getGroupRowIdFromPath } from './utils';
import { GridTreePathDuplicateHandler, RowTreeBuilderGroupingCriterion } from './models';

interface InsertDataRowInTreeParams {
  /**
   * ID of the data row to insert in the tree.
   */
  id: GridRowId;
  /**
   * Path of the data row to insert in the tree.
   */
  path: RowTreeBuilderGroupingCriterion[];
  /**
   * Tree in which to insert the data row.
   * This tree can be mutated but it's children should not.
   * For instance:
   *
   * - `tree[nodeId] = newNode` => valid
   * - `tree[nodeId].children.push(newNodeId)` => invalid
   */
  tree: Record<GridRowId, GridTreeNode>;
  /**
   * Lookup listing all the auto-generated rows, with their ids for keys and values.
   * This lookup can be mutated.
   * For instance:
   *
   * - `delete autoGeneratedRowIdToIdLookup[nodeId]` => valid
   */
  autoGeneratedRowIdToIdLookup: Record<string, GridRowId>;
  /**
   * Callback fired when trying to insert a data row for a path already populated by another data row.
   */
  onDuplicatePath?: GridTreePathDuplicateHandler;
}

/**
 * Inserts a data row in a tree.
 * For each steps of its path:
 * - if a node exists with the same partial path, it will register this node as the ancestor of the data row.
 * - if not, it will create an auto-generated node and register it as ancestor of the data row.
 */
export const insertDataRowInTree = ({
  id,
  path,
  tree,
  autoGeneratedRowIdToIdLookup,
  onDuplicatePath,
}: InsertDataRowInTreeParams) => {
  const addChildrenToNode = (
    groupId: GridRowId,
    childId: GridRowId,
    field: string,
    key: GridKeyValue,
  ) => {
    const groupNode = tree[groupId] as GridGroupNode;

    tree[groupId] = {
      ...groupNode,
      childrenFromPath: {
        ...groupNode.childrenFromPath,
        [field]: {
          ...groupNode.childrenFromPath?.[field],
          [key.toString()]: childId,
        },
      },
      children: [...groupNode.children, childId],
    };
  };

  let parentNodeId = GRID_ROOT_GROUP_ID;

  for (let depth = 0; depth < path.length; depth += 1) {
    const { key, field: rawField } = path[depth];
    const field = rawField ?? '__no_field__';
    const existingNodeIdWithCurrentPath = (tree[parentNodeId] as GridGroupNode).childrenFromPath?.[
      field
    ]?.[key.toString()];

    // For the last step of the path, we need to create a node for the row passed to `insertNodeInTree`
    if (depth === path.length - 1) {
      // If we already have an auto-generated group in place, we replace it with the row passed to `insertNodeInTree`
      if (existingNodeIdWithCurrentPath) {
        const existingNodeWithCurrentPath = tree[existingNodeIdWithCurrentPath];

        if (
          existingNodeWithCurrentPath.type === 'group' &&
          existingNodeWithCurrentPath.isAutoGenerated
        ) {
          delete tree[existingNodeWithCurrentPath.id];
          delete autoGeneratedRowIdToIdLookup[existingNodeWithCurrentPath.id];

          addChildrenToNode(parentNodeId, id, field, key);

          // TODO: Can we avoid this linear complexity ?
          const parentNode = tree[parentNodeId] as GridGroupNode;
          tree[parentNodeId] = {
            ...parentNode,
            children: parentNode.children.filter(
              (childId) => childId !== existingNodeIdWithCurrentPath,
            ),
          };

          existingNodeWithCurrentPath.children.forEach((childId) => {
            tree[childId] = {
              ...tree[childId],
              parent: id,
            };
          });

          tree[id] = {
            ...existingNodeWithCurrentPath,
            id,
          };
        } else {
          onDuplicatePath?.(existingNodeIdWithCurrentPath, id, path);
        }
      } else {
        addChildrenToNode(parentNodeId, id, field, key);

        tree[id] = {
          type: 'leaf',
          id,
          depth,
          parent: parentNodeId,
          groupingKey: key,
        };
      }
    }
    // For the intermediary steps of the path
    // If no node matches the partial path, we create an auto-generated node
    else if (existingNodeIdWithCurrentPath == null) {
      const nodeId = getGroupRowIdFromPath(path.slice(0, depth + 1));
      addChildrenToNode(parentNodeId, nodeId, field, key);
      autoGeneratedRowIdToIdLookup[nodeId] = nodeId;

      tree[nodeId] = {
        type: 'group',
        id: nodeId,
        parent: parentNodeId,
        depth,
        isAutoGenerated: true,
        groupingKey: key,
        groupingField: rawField,
        children: [],
        childrenFromPath: {},
      };
      parentNodeId = nodeId;
    }
    // For the intermediary steps of the path
    // If a node matches the partial path, we use it as parent for the next step
    else {
      const currentGroupNode = tree[existingNodeIdWithCurrentPath];

      // If the node matching the partial path is not a group, we turn it into a group
      if (currentGroupNode.type !== 'group') {
        tree[existingNodeIdWithCurrentPath] = {
          type: 'group',
          id: currentGroupNode.id,
          parent: currentGroupNode.parent,
          depth: currentGroupNode.depth,
          isAutoGenerated: false,
          groupingKey: key,
          groupingField: rawField,
          children: [],
          childrenFromPath: {},
        };
      }
      parentNodeId = currentGroupNode.id;
    }
  }
};
