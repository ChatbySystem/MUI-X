import { GRID_ROOT_GROUP_ID, GridGroupNode, GridRowId, GridTreeNode } from '@mui/x-data-grid';
import { getGroupRowIdFromPath } from './utils';
import { GridTreePathDuplicateHandler, RowTreeBuilderGroupingCriterion } from './models';

export const insertNodeInTree = ({
  id,
  path,
  tree,
  autoGeneratedRowIdToIdLookup,
  onDuplicatePath,
}: {
  id: GridRowId;
  path: RowTreeBuilderGroupingCriterion[];
  tree: Record<GridRowId, GridTreeNode>;
  autoGeneratedRowIdToIdLookup: Record<string, GridRowId>;
  onDuplicatePath?: GridTreePathDuplicateHandler;
}) => {
  let parentNode = tree[GRID_ROOT_GROUP_ID] as GridGroupNode;

  for (let depth = 0; depth < path.length; depth += 1) {
    const { key, field: rawField } = path[depth];
    const field = rawField ?? '__no_field__';

    if (!parentNode.childrenFromPath[field]) {
      parentNode = {
        ...parentNode,
        childrenFromPath: {
          ...parentNode.childrenFromPath,
          [field]: {},
        },
      };
      tree[parentNode.id] = parentNode;
    }

    const existingNodeIdWithCurrentPath = parentNode.childrenFromPath[field][key.toString()];

    // For the last step of the path, we need to create a node for the row passed to `insertNodeInTree`
    if (depth === path.length - 1) {
      // If we already have an auto-generated group in place, we replace it with the row passed to `insertNodeInTree`
      if (existingNodeIdWithCurrentPath) {
        const existingNodeWithCurrentPath = tree[existingNodeIdWithCurrentPath];

        if (
          existingNodeWithCurrentPath.type === 'group' &&
          existingNodeWithCurrentPath.isAutoGenerated
        ) {
          delete tree[existingNodeWithCurrentPath.id];
          delete autoGeneratedRowIdToIdLookup[existingNodeWithCurrentPath.id];

          parentNode = {
            ...parentNode,
            childrenFromPath: {
              ...parentNode.childrenFromPath,
              [field]: {
                ...parentNode.childrenFromPath[field],
                [key.toString()]: id,
              },
            },
            // TODO: Can we avoid this linear complexity
            children: [
              ...parentNode.children.filter((childId) => childId !== existingNodeIdWithCurrentPath),
              id,
            ],
          };
          tree[parentNode.id] = parentNode;

          existingNodeWithCurrentPath.children.forEach((childId) => {
            tree[childId] = {
              ...tree[childId],
              parent: id,
            };
          });

          tree[id] = {
            ...existingNodeWithCurrentPath,
            id,
          };
        } else {
          onDuplicatePath?.(existingNodeIdWithCurrentPath, id, path);
        }
      } else {
        parentNode = {
          ...parentNode,
          childrenFromPath: {
            ...parentNode.childrenFromPath,
            [field]: {
              ...parentNode.childrenFromPath[field],
              [key.toString()]: id,
            },
          },
          children: [...parentNode.children, id],
        };
        tree[parentNode.id] = parentNode;

        tree[id] = {
          type: 'leaf',
          id,
          depth,
          parent: parentNode.id,
          groupingKey: key,
        };
      }
    }
    // For the intermediary steps of the path
    // If no node matches the partial path, we create an auto-generated node
    else if (existingNodeIdWithCurrentPath == null) {
      const nodeId = getGroupRowIdFromPath(path.slice(0, depth + 1));

      parentNode = {
        ...parentNode,
        childrenFromPath: {
          ...parentNode.childrenFromPath,
          [field]: {
            ...parentNode.childrenFromPath[field],
            [key.toString()]: nodeId,
          },
        },
        children: [...parentNode.children, nodeId],
      };
      tree[parentNode.id] = parentNode;

      autoGeneratedRowIdToIdLookup[nodeId] = nodeId;

      const groupNode: GridGroupNode = {
        type: 'group',
        id: nodeId,
        depth,
        isAutoGenerated: true,
        groupingKey: key,
        groupingField: rawField,
        children: [],
        childrenFromPath: {},
        parent: parentNode.id,
      };

      tree[nodeId] = groupNode;
      parentNode = groupNode;
    }
    // For the intermediary steps of the path
    // If a node matches the partial path, we use it as parent for the next step
    else {
      const currentGroupNode = tree[existingNodeIdWithCurrentPath];

      // If the node matching the partial path is not a group, we turn it into a group
      if (currentGroupNode.type !== 'group') {
        const groupNode: GridGroupNode = {
          type: 'group',
          id: currentGroupNode.id,
          depth: currentGroupNode.depth,
          parent: currentGroupNode.parent,
          isAutoGenerated: false,
          groupingKey: key,
          groupingField: rawField,
          children: [],
          childrenFromPath: {},
        };

        tree[existingNodeIdWithCurrentPath] = groupNode;

        parentNode = groupNode;
      } else {
        parentNode = currentGroupNode;
      }
    }
  }
};
