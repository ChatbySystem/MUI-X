import { GridRowId, GridGroupNode, GridTreeNode, GRID_ROOT_GROUP_ID } from '@mui/x-data-grid';
import { GridRowTreeCreationValue } from '@mui/x-data-grid/internals';
import { RowTreeBuilderNode, GridTreePathDuplicateHandler } from './models';
import { insertNodeInTree } from './insertNodeInTree';

interface CreateRowTreeParams {
  autoGeneratedRowIdToIdLookup: Record<string, GridRowId>;
  nodes: RowTreeBuilderNode[];
  defaultGroupingExpansionDepth: number;
  isGroupExpandedByDefault?: (node: GridGroupNode) => boolean;
  groupingName: string;
  onDuplicatePath?: GridTreePathDuplicateHandler;
}

/**
 * Transform a list of rows into a tree structure where each row references its parent and children.
 * If a row have a parent which does not exist in the input rows, creates an auto generated row
 *
 ```
 params = {
   ids: [0, 1, 2],
   idRowsLookup: { 0: {...}, 1: {...}, 2: {...} },
   rows: [
     { id: 0, path: ['A'] },
     { id: 1, path: ['B', 'A'] },
     { id: 2, path: ['B', 'A', 'A'] }
   ],
   defaultGroupingExpansionDepth: 0,
 }
 Returns:
 {
   ids: [0, 1, 2, 'auto-generated-row-B'],
   idRowsLookup: { 0: {...}, 1: {...}, 2: {...}, 'auto-generated-row-B': {} },
   tree: {
     '0': { id: 0, parent: null, childrenExpanded: false, depth: 0, groupingKey: 'A' },
     'auto-generated-row-B': { id: 'auto-generated-row-B', parent: null, childrenExpanded: false, depth: 0, groupingKey: 'B' },
     '1': { id: 1, parent: 'auto-generated-row-B', childrenExpanded: false, depth: 1, groupingKey: 'A' },
     '2': { id: 2, parent: 1, childrenExpanded: false, depth: 2, groupingKey: 'A' },
   },
   treeDepth: 3,
 }
 ```
 */
export const createRowTree = (params: CreateRowTreeParams): GridRowTreeCreationValue => {
  const gridRootGroupNode: GridGroupNode = {
    type: 'group',
    id: GRID_ROOT_GROUP_ID,
    depth: -1,
    groupingField: null,
    groupingKey: null,
    isAutoGenerated: true,
    children: [],
    childrenFromPath: {},
    parent: null,
  };

  const tree: Record<GridRowId, GridTreeNode> = {
    [GRID_ROOT_GROUP_ID]: gridRootGroupNode,
  };
  let treeDepth = 1;

  const autoGeneratedRowIdToIdLookup = { ...params.autoGeneratedRowIdToIdLookup };

  const isGroupExpandedByDefault = (node: GridGroupNode) => {
    if (node.id === GRID_ROOT_GROUP_ID) {
      return true;
    }

    if (Object.keys(node.children).length === 0) {
      return false;
    }

    if (params.isGroupExpandedByDefault) {
      return params.isGroupExpandedByDefault(node);
    }

    return (
      params.defaultGroupingExpansionDepth === -1 ||
      params.defaultGroupingExpansionDepth > node.depth
    );
  };

  for (let i = 0; i < params.nodes.length; i += 1) {
    const node = params.nodes[i];

    insertNodeInTree({
      tree,
      autoGeneratedRowIdToIdLookup,
      id: node.id,
      path: node.path,
      onDuplicatePath: params.onDuplicatePath,
    });

    treeDepth = Math.max(treeDepth, node.path.length);
  }

  const postProcessNode = (node: GridTreeNode) => {
    if (node.type === 'footer' || node.type === 'leaf') {
      tree[node.id] = node;
    } else {
      tree[node.id] = {
        ...node,
        childrenExpanded: isGroupExpandedByDefault(node),
      };

      for (let i = 0; i < node.children.length; i += 1) {
        postProcessNode(tree[node.children[i]]);
      }
    }
  };

  postProcessNode(gridRootGroupNode);

  return {
    tree,
    treeDepth,
    autoGeneratedRowIdToIdLookup,
    groupingName: params.groupingName,
  };
};
