import {
  GRID_ROOT_GROUP_ID,
  GridGroupNode,
  GridRowId,
  GridRowsLookup,
  GridTreeNode,
} from '@mui/x-data-grid';

export const removeNodeFromTree = ({
  id,
  tree,
  idRowsLookup,
  idToIdLookup,
}: {
  id: GridRowId;
  tree: Record<GridRowId, GridTreeNode>;
  idRowsLookup: GridRowsLookup;
  idToIdLookup: Record<string, GridRowId>;
}) => {
  const removeNodeIfNoRemainingChildren = (
    groupNode: GridGroupNode,
    removedChildNode: GridTreeNode,
  ) => {
    // TODO: Avoid linear complexity
    const children = groupNode.children.filter((childId) => childId !== removedChildNode.id);

    if (children.length === 0 && groupNode.id !== GRID_ROOT_GROUP_ID) {
      if (groupNode.isAutoGenerated) {
        delete tree[groupNode.id];
        delete idToIdLookup[groupNode.id];
        delete idRowsLookup[groupNode.id];

        removeNodeIfNoRemainingChildren(tree[groupNode.parent!] as GridGroupNode, groupNode);
      } else {
        tree[groupNode.id] = {
          type: 'leaf',
          id: groupNode.id,
          depth: groupNode.depth,
          parent: groupNode.parent!,
          groupingKey: groupNode.groupingKey,
        };
      }
    } else {
      const groupingField = (removedChildNode as GridGroupNode).groupingField ?? '__no_field__';
      const groupingKey = (removedChildNode as GridGroupNode).groupingKey ?? '__no_key__';

      const { [groupingKey.toString()]: childrenToRemove, ...newChildrenFromPathWithField } =
        groupNode.childrenFromPath[groupingField];

      tree[groupNode.id] = {
        ...groupNode,
        children,
        childrenFromPath: {
          ...groupNode.childrenFromPath,
          // TODO: If `newChildrenFromPathWithField`, do not put it in the tree at all
          [groupingField]: newChildrenFromPathWithField,
        },
      };
    }
  };

  const node = tree[id];
  removeNodeIfNoRemainingChildren(tree[node.parent!] as GridGroupNode, node);

  delete tree[id];
};
