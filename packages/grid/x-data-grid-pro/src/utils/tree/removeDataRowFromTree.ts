import {
  GRID_ROOT_GROUP_ID,
  GridChildrenFromPathLookup,
  GridGroupNode,
  GridRowId,
  GridTreeNode,
} from '@mui/x-data-grid';

interface RemoveDataRowFromTreeParams {
  /**
   * ID of the data row to remove from the tree.
   */
  id: GridRowId;
  /**
   * Tree from which to remove the data row.
   * This tree can be mutated but it's children should not.
   * For instance:
   *
   * - `tree[nodeId] = newNode` => valid
   * - `tree[nodeId].children.push(newNodeId)` => invalid
   */
  tree: Record<GridRowId, GridTreeNode>;
  /**
   * Lookup listing all the auto-generated rows, with their ids for keys and values.
   * This lookup can be mutated.
   * For instance:
   *
   * - `delete autoGeneratedRowIdToIdLookup[nodeId]` => valid
   */
  autoGeneratedRowIdToIdLookup: Record<string, GridRowId>;
}

export const removeDataRowFromTree = ({
  id,
  tree,
  autoGeneratedRowIdToIdLookup,
}: RemoveDataRowFromTreeParams) => {
  const removeNodeIfNoRemainingChildren = (
    groupNode: GridGroupNode,
    removedChildNode: GridTreeNode,
  ) => {
    const groupingField = (removedChildNode as GridGroupNode).groupingField ?? '__no_field__';
    const groupingKey = (removedChildNode as GridGroupNode).groupingKey ?? '__no_key__';

    const { [groupingKey.toString()]: childrenToRemove, ...newChildrenFromPathWithField } =
      groupNode.childrenFromPath?.[groupingField] ?? {};

    // TODO: Avoid linear complexity
    const children = groupNode.children.filter((childId) => childId !== removedChildNode.id);
    const childrenFromPath: GridChildrenFromPathLookup = { ...groupNode.childrenFromPath };
    if (Object.keys(newChildrenFromPathWithField).length === 0) {
      delete childrenFromPath[groupingField];
    } else {
      childrenFromPath[groupingField] = newChildrenFromPathWithField;
    }

    tree[groupNode.id] = {
      ...groupNode,
      children,
      childrenFromPath,
    };

    const shouldDeleteGroup = groupNode.id !== GRID_ROOT_GROUP_ID && children.length === 0;
    if (shouldDeleteGroup) {
      if (groupNode.footerId != null) {
        delete tree[groupNode.footerId];
        delete autoGeneratedRowIdToIdLookup[groupNode.footerId];
      }

      if (groupNode.isAutoGenerated) {
        delete tree[groupNode.id];
        delete autoGeneratedRowIdToIdLookup[groupNode.id];

        removeNodeIfNoRemainingChildren(tree[groupNode.parent!] as GridGroupNode, groupNode);
      } else {
        tree[groupNode.id] = {
          type: 'leaf',
          id: groupNode.id,
          depth: groupNode.depth,
          parent: groupNode.parent!,
          groupingKey: groupNode.groupingKey,
        };
      }
    }
  };

  const node = tree[id];
  removeNodeIfNoRemainingChildren(tree[node.parent!] as GridGroupNode, node);

  delete tree[id];
};
