import {
  GRID_ROOT_GROUP_ID,
  GridChildrenFromPathLookup,
  GridGroupNode,
  GridRowId,
  GridTreeNode,
} from '@mui/x-data-grid';
import { removeNodeFromTree } from '@mui/x-data-grid-pro/utils/tree/utils';

interface RemoveDataRowFromTreeParams {
  /**
   * ID of the data row to remove from the tree.
   */
  id: GridRowId;
  /**
   * Tree from which to remove the data row.
   * This tree can be mutated but it's children should not.
   * For instance:
   *
   * - `tree[nodeId] = newNode` => valid
   * - `tree[nodeId].children.push(newNodeId)` => invalid
   */
  tree: Record<GridRowId, GridTreeNode>;
  /**
   * Amount of nodes at each depth of the tree.
   * This object can be mutated.
   * For instance:
   *
   * - `treeDepths[nodeDepth] = treeDepth[nodeDepth] + 1` => valid
   */
  treeDepths: { [depth: number]: number };
}

export const removeDataRowFromTree = ({ id, tree, treeDepths }: RemoveDataRowFromTreeParams) => {
  const cleanParentNode = (groupNode: GridGroupNode, removedChildNode: GridTreeNode) => {
    const groupingField = (removedChildNode as GridGroupNode).groupingField ?? '__no_field__';
    const groupingKey = (removedChildNode as GridGroupNode).groupingKey ?? '__no_key__';

    const { [groupingKey.toString()]: childrenToRemove, ...newChildrenFromPathWithField } =
      groupNode.childrenFromPath?.[groupingField] ?? {};

    // TODO rows v6: Avoid linear complexity
    const children = groupNode.children.filter((childId) => childId !== removedChildNode.id);
    const childrenFromPath: GridChildrenFromPathLookup = { ...groupNode.childrenFromPath };
    if (Object.keys(newChildrenFromPathWithField).length === 0) {
      delete childrenFromPath[groupingField];
    } else {
      childrenFromPath[groupingField] = newChildrenFromPathWithField;
    }

    tree[groupNode.id] = {
      ...groupNode,
      children,
      childrenFromPath,
    };

    const shouldDeleteGroup = groupNode.id !== GRID_ROOT_GROUP_ID && children.length === 0;
    if (shouldDeleteGroup) {
      if (groupNode.footerId != null) {
        removeNodeFromTree({
          id: groupNode.footerId,
          tree,
          treeDepths,
        });
      }

      if (groupNode.isAutoGenerated) {
        removeNodeFromTree({
          id: groupNode.id,
          tree,
          treeDepths,
        });

        cleanParentNode(tree[groupNode.parent!] as GridGroupNode, groupNode);
      } else {
        tree[groupNode.id] = {
          type: 'leaf',
          id: groupNode.id,
          depth: groupNode.depth,
          parent: groupNode.parent!,
          groupingKey: groupNode.groupingKey,
        };
      }
    }
  };

  const node = tree[id];
  removeNodeFromTree({
    id,
    tree,
    treeDepths,
  });

  cleanParentNode(tree[node.parent!] as GridGroupNode, node);
};
