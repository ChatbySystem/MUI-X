import * as React from 'react';
import MuiDivider from '@mui/material/Divider';
import { GridPreferencePanelsValue } from '@mui/x-data-grid';
import { GridPreProcessor, useGridRegisterPreProcessor } from '@mui/x-data-grid/internals';
import { GridApiPro } from '../../../models/gridApiPro';
import {
  getAvailableAggregationFunctions,
  wrapColumnWithAggregation,
} from './gridAggregationUtils';
import { DataGridProProcessedProps } from '../../../models/dataGridProProps';
import { GridAggregationColumnMenuItems } from '../../../components/GridAggregationColumnMenuItems';
import { GridAggregationPanel } from '../../../components/GridAggregationPanel';

const Divider = () => <MuiDivider onClick={(event) => event.stopPropagation()} />;

export const useGridAggregationPreProcessors = (
  apiRef: React.MutableRefObject<GridApiPro>,
  props: Pick<DataGridProProcessedProps, 'aggregationFunctions' | 'aggregationPosition'>,
) => {
  const aggregationPositionRef = React.useRef(props.aggregationPosition);
  aggregationPositionRef.current = props.aggregationPosition;

  // TODO: Add ability to clear current aggregation
  const updateGroupingColumn = React.useCallback<GridPreProcessor<'hydrateColumns'>>(
    (columnsState) => {
      console.log('HEY');
      columnsState.all.forEach((field) => {
        const colDef = columnsState.lookup[field];

        const wrappedColDef = wrapColumnWithAggregation({
          colDef,
          apiRef,
          aggregationFunctions: props.aggregationFunctions,
          aggregationPositionRef,
        });

        columnsState.lookup[field] = wrappedColDef;
      });

      return columnsState;
    },
    [apiRef, props.aggregationFunctions, aggregationPositionRef],
  );

  const addGroupFooterRows = React.useCallback<GridPreProcessor<'hydrateRows'>>(
    (groupingParams) => {
      if (props.aggregationPosition === 'inline') {
        return groupingParams;
      }

      const ids = [...groupingParams.ids];
      const idRowsLookup = { ...groupingParams.idRowsLookup };
      const tree = { ...groupingParams.tree };

      groupingParams.ids.forEach((parentId) => {
        const node = tree[parentId];

        if (node.depth === groupingParams.treeDepth - 1) {
          return;
        }

        const footerId = `auto-generated-group-footer-${parentId}`;

        ids.push(footerId);
        idRowsLookup[footerId] = {};
        tree[footerId] = {
          id: footerId,
          isAutoGenerated: true,
          parent: parentId,
          depth: node.depth + 1,
          groupingKey: null,
          groupingField: null,
        };

        tree[parentId] = {
          ...tree[parentId],
          children: [...(tree[parentId].children ?? []), footerId],
        };
      });

      return {
        ...groupingParams,
        ids,
        idRowsLookup,
        tree,
      };
    },
    [props.aggregationPosition],
  );

  const addColumnMenuButtons = React.useCallback<GridPreProcessor<'columnMenu'>>(
    (initialValue, column) => {
      const availableAggregationFunction = getAvailableAggregationFunctions({
        aggregationFunctions: props.aggregationFunctions,
        column,
      });
      if (availableAggregationFunction.length === 0) {
        return initialValue;
      }

      return [...initialValue, <Divider />, <GridAggregationColumnMenuItems />];
    },
    [props.aggregationFunctions],
  );

  const preferencePanelPreProcessing = React.useCallback<GridPreProcessor<'preferencePanel'>>(
    (initialValue, value) => {
      if (value === GridPreferencePanelsValue.aggregation) {
        return <GridAggregationPanel />;
      }

      return initialValue;
    },
    [],
  );

  useGridRegisterPreProcessor(apiRef, 'hydrateColumns', updateGroupingColumn);
  useGridRegisterPreProcessor(apiRef, 'hydrateRows', addGroupFooterRows);
  useGridRegisterPreProcessor(apiRef, 'columnMenu', addColumnMenuButtons);
  useGridRegisterPreProcessor(apiRef, 'preferencePanel', preferencePanelPreProcessing);
};
