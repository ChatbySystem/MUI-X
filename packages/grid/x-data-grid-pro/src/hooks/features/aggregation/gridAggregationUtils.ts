import * as React from 'react';
import {
  GridColDef,
  GridRowId,
  gridRowIdsSelector,
  GridValueFormatterParams,
} from '@mui/x-data-grid';
import { GridColumnRawLookup, isNumber } from '@mui/x-data-grid/internals';
import { GridApiPro } from '../../../models/gridApiPro';
import {
  GridAggregationFunction,
  GridAggregationItem,
  GridAggregationModel,
} from './gridAggregationInterfaces';
import { GridStatePro } from '../../../models/gridStatePro';

const sumAgg: GridAggregationFunction<number> = {
  apply: ({ values }) => {
    let sum = 0;
    for (let i = 0; i < values.length; i += 1) {
      sum += values[i];
    }

    return sum;
  },
  types: ['number'],
};

const minAgg: GridAggregationFunction<number> = {
  apply: ({ values }) => {
    if (values.length === 0) {
      return Number.NaN;
    }

    let min: number = +Infinity;
    for (let i = 0; i < values.length; i += 1) {
      const value = values[i];
      if (value < min) {
        min = value;
      }
    }

    return min;
  },
  types: ['number'],
};

const maxAgg: GridAggregationFunction<number> = {
  apply: ({ values }) => {
    if (values.length === 0) {
      return Number.NaN;
    }

    let max: number = -Infinity;
    for (let i = 0; i < values.length; i += 1) {
      const value = values[i];
      if (value > max) {
        max = value;
      }
    }

    return max;
  },
  types: ['number'],
};

const avgAgg: GridAggregationFunction<number> = {
  apply: (params) => {
    if (params.values.length === 0) {
      return Number.NaN;
    }

    const sum = sumAgg.apply(params);
    return sum / params.values.length;
  },
  types: ['number'],
};

const sizeAgg: GridAggregationFunction<number> = {
  apply: ({ values }) => {
    return values.length;
  },
  valueFormatter: (params: GridValueFormatterParams) => {
    if (params.value == null || !isNumber(params.value)) {
      return params.value;
    }

    return params.value.toLocaleString();
  },
  types: ['number'],
};

export const GRID_AGGREGATION_FUNCTIONS = {
  avg: avgAgg,
  min: minAgg,
  max: maxAgg,
  size: sizeAgg,
  sum: sumAgg,
};

type AggregationWrappedMethod<M extends Function | undefined> = M & {
  originalMethod?: M;
  isWrappedWithAggregation?: boolean;
};

export const wrapColumnWithAggregation = ({
  colDef,
  apiRef,
  currentAggregation,
  aggregationFunctions,
  aggregationPositionRef,
}: {
  colDef: GridColDef;
  apiRef: React.MutableRefObject<GridApiPro>;
  currentAggregation: GridAggregationItem;
  aggregationFunctions: Record<string, GridAggregationFunction>;
  aggregationPositionRef: React.RefObject<'inline' | 'footer'>;
}) => {
  const aggregationFunction = aggregationFunctions?.[currentAggregation.method];

  const { valueGetter: originalValueGetter, valueFormatter: originalValueFormatter } = colDef;

  if (!aggregationFunction) {
    throw new Error(`MUI: No aggregation registered with the name ${currentAggregation}`);
  }

  if (!aggregationFunction.types.includes(colDef.type!)) {
    throw new Error(
      `MUI: The current aggregation function is not application to the type "${colDef.type}"`,
    );
  }

  const getCellAggregationMode = (id: GridRowId) => {
    const isGroup = id.toString().startsWith('auto-generated-row-');

    if (isGroup && aggregationPositionRef.current === 'inline') {
      return 'inline';
    }

    const isFooter = id.toString().startsWith('auto-generated-group-footer-');
    if (isFooter && aggregationPositionRef.current === 'footer') {
      return 'footer';
    }

    return null;
  };

  const wrappedValueGetter: AggregationWrappedMethod<GridColDef['valueGetter']> = (params) => {
    if (params.rowNode.isAutoGenerated) {
      const cellAggregationMode = getCellAggregationMode(params.id);

      if (cellAggregationMode) {
        let rowIds: GridRowId[] | undefined;
        if (cellAggregationMode === 'footer') {
          if (params.rowNode.parent == null) {
            rowIds = gridRowIdsSelector(apiRef);
          } else {
            rowIds = apiRef.current.getRowNode(params.rowNode.parent)?.children;
          }
        } else {
          rowIds = params.rowNode.children;
        }

        const validRowIds = (rowIds ?? []).filter(
          (rowId) => !apiRef.current.getRowNode(rowId)?.isAutoGenerated,
        );

        return aggregationFunction.apply({
          values: validRowIds.map((rowId) => apiRef.current.getCellValue(rowId, params.field)),
        });
      }
    }

    if (originalValueGetter) {
      return originalValueGetter(params);
    }

    return params.row[params.field];
  };

  const wrappedValueFormatter: AggregationWrappedMethod<GridColDef['valueFormatter']> = (
    params,
  ) => {
    if (params.id != null && aggregationFunction.valueFormatter) {
      const cellAggregationMode = getCellAggregationMode(params.id);
      if (cellAggregationMode) {
        return aggregationFunction.valueFormatter(params);
      }
    }

    if (originalValueFormatter) {
      return originalValueFormatter(params);
    }

    return params.value;
  };

  wrappedValueGetter.isWrappedWithAggregation = true;
  wrappedValueGetter.originalMethod = originalValueGetter;
  wrappedValueFormatter.isWrappedWithAggregation = true;
  wrappedValueFormatter.originalMethod = originalValueFormatter;

  return {
    ...colDef,
    valueGetter: wrappedValueGetter,
    valueFormatter: wrappedValueFormatter,
  };
};

export const unwrapColumnFromAggregation = ({ colDef }: { colDef: GridColDef }) => {
  const valueGetter = colDef.valueGetter as AggregationWrappedMethod<GridColDef['valueGetter']>;
  const valueFormatter = colDef.valueFormatter as AggregationWrappedMethod<
    GridColDef['valueFormatter']
  >;
  if (valueGetter?.isWrappedWithAggregation || valueFormatter?.isWrappedWithAggregation) {
    return {
      ...colDef,
      valueGetter: valueGetter?.isWrappedWithAggregation
        ? valueGetter.originalMethod
        : colDef.valueGetter,
      valueFormatter: valueFormatter?.isWrappedWithAggregation
        ? valueFormatter.originalMethod
        : colDef.valueFormatter,
    };
  }

  return colDef;
};

export const getAvailableAggregationFunctions = ({
  aggregationFunctions,
  column,
}: {
  aggregationFunctions: Record<string, GridAggregationFunction>;
  column: GridColDef;
}) => {
  if (column.aggregable === false) {
    return [];
  }

  if (column.availableAggregationFunctions != null) {
    return column.availableAggregationFunctions;
  } else {
    return Object.keys(aggregationFunctions).filter((name) =>
      aggregationFunctions[name].types.includes(column.type!),
    );
  }
};

export const mergeStateWithAggregationModel =
  (aggregationModel: GridAggregationModel) =>
  (state: GridStatePro): GridStatePro => ({
    ...state,
    aggregation: { ...state.aggregation, model: aggregationModel },
  });

export const sanitizeAggregationModel = (
  model: GridAggregationModel,
  columnsLookup: GridColumnRawLookup,
) => {
  const sanitizedModel: GridAggregationModel = {};

  Object.keys(model).forEach((field) => {
    if (columnsLookup[field] && columnsLookup[field].aggregable !== false) {
      sanitizedModel[field] = model[field];
    }
  });

  return model;
};
