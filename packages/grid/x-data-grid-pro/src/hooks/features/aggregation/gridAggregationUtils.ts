import * as React from 'react';
import {
  GridColDef,
  GridRowId,
  gridRowIdsSelector,
  GridRowTreeConfig,
  GridRowTreeNodeConfig,
  gridRowTreeSelector,
} from '@mui/x-data-grid';
import { GridColumnRawLookup, GridRowTreeCreationValue } from '@mui/x-data-grid/internals';
import { GridApiPro } from '../../../models/gridApiPro';
import {
  GridAggregationCellMeta,
  GridAggregationFunction,
  GridAggregationModel,
  GridAggregationPosition,
} from './gridAggregationInterfaces';
import { GridStatePro } from '../../../models/gridStatePro';
import { DataGridProProcessedProps } from '../../../models/dataGridProProps';

const AGGREGATION_WRAPPABLE_METHODS = [
  'valueGetter',
  'valueFormatter',
  'renderCell',
  'filterOperators',
] as const;

type AggregationWrappedObject<M extends Function | object> = M & {
  originalMethod?: M;
  isWrappedWithAggregation?: boolean;
};

type AggregationWrappedVariable<M extends Function | object[]> = M extends Function
  ? AggregationWrappedObject<M> | undefined
  : M extends object[]
  ? AggregationWrappedObject<M>[number][]
  : never;

type AggregationWrappedColDefProperty<M extends typeof AGGREGATION_WRAPPABLE_METHODS[number]> =
  AggregationWrappedVariable<NonNullable<GridColDef[M]>>;

const getNonAutoGeneratedDescendants = (tree: GridRowTreeConfig, parentId: GridRowId) => {
  const children = tree[parentId].children;
  if (children == null) {
    return [];
  }

  const validDescendants: GridRowId[] = [];
  for (let i = 0; i < children.length; i += 1) {
    const child = children[i];
    const childNode = tree[child];
    if (!childNode.isAutoGenerated) {
      validDescendants.push(child);
    }
    validDescendants.push(...getNonAutoGeneratedDescendants(tree, childNode.id));
  }

  return validDescendants;
};

const getWrappedValueGetter = ({
  apiRef,
  valueGetter,
  aggregationFunction,
  getCellAggregationPosition,
}: {
  apiRef: React.MutableRefObject<GridApiPro>;
  valueGetter: GridColDef['valueGetter'];
  aggregationFunction: GridAggregationFunction;
  getCellAggregationPosition: (id: GridRowId) => GridAggregationPosition | null;
}): AggregationWrappedColDefProperty<'valueGetter'> => {
  const wrappedValueGetter: AggregationWrappedColDefProperty<'valueGetter'> = (params) => {
    if (params.rowNode.isAutoGenerated) {
      const cellAggregationPosition = getCellAggregationPosition(params.id);
      if (cellAggregationPosition) {
        const rowTree = gridRowTreeSelector(apiRef);

        let rowIds: GridRowId[];
        if (cellAggregationPosition === 'footer') {
          if (params.rowNode.parent == null) {
            rowIds = gridRowIdsSelector(apiRef).filter((id) => !rowTree[id].isAutoGenerated);
          } else {
            rowIds = getNonAutoGeneratedDescendants(rowTree, params.rowNode.parent);
          }
        } else {
          rowIds = getNonAutoGeneratedDescendants(rowTree, params.rowNode.id);
        }

        return aggregationFunction.apply({
          values: rowIds.map((rowId) => apiRef.current.getCellValue(rowId, params.field)),
        });
      }
    }

    if (valueGetter) {
      return valueGetter(params);
    }

    return params.row[params.field];
  };

  wrappedValueGetter.isWrappedWithAggregation = true;
  wrappedValueGetter.originalMethod = valueGetter;

  return wrappedValueGetter;
};

const getWrappedValueFormatter = ({
  valueFormatter,
  aggregationFunction,
  getCellAggregationPosition,
}: {
  valueFormatter: GridColDef['valueFormatter'];
  aggregationFunction: GridAggregationFunction;
  getCellAggregationPosition: (id: GridRowId) => GridAggregationPosition | null;
}): AggregationWrappedColDefProperty<'valueFormatter'> | undefined => {
  if (!aggregationFunction.valueFormatter) {
    return valueFormatter;
  }

  const wrappedValueFormatter: AggregationWrappedColDefProperty<'valueFormatter'> = (params) => {
    if (params.id != null) {
      const cellAggregationPosition = getCellAggregationPosition(params.id);
      if (cellAggregationPosition) {
        return aggregationFunction.valueFormatter!(params);
      }
    }

    if (valueFormatter) {
      return valueFormatter(params);
    }

    return params.value;
  };

  wrappedValueFormatter.isWrappedWithAggregation = true;
  wrappedValueFormatter.originalMethod = valueFormatter;

  return wrappedValueFormatter;
};

const getWrappedRenderCell = ({
  renderCell,
  aggregationFunction,
  aggregationItem,
  getCellAggregationPosition,
}: {
  renderCell: GridColDef['renderCell'];
  aggregationFunction: GridAggregationFunction;
  aggregationItem: string;
  getCellAggregationPosition: (id: GridRowId) => GridAggregationPosition | null;
}): AggregationWrappedColDefProperty<'renderCell'> | undefined => {
  if (!renderCell) {
    return undefined;
  }

  const aggregationMeta: GridAggregationCellMeta = {
    hasCellUnit: aggregationFunction.hasCellUnit ?? true,
    item: aggregationItem,
  };

  const wrappedRenderCell: AggregationWrappedColDefProperty<'renderCell'> = (params) => {
    const cellAggregationPosition = getCellAggregationPosition(params.id);
    if (cellAggregationPosition) {
      return renderCell({ ...params, aggregation: aggregationMeta });
    }

    return renderCell(params);
  };
  wrappedRenderCell.isWrappedWithAggregation = true;
  wrappedRenderCell.originalMethod = renderCell;

  return wrappedRenderCell;
};

const getWrappedFilterOperators = ({
  filterOperators,
  getCellAggregationPosition,
}: {
  filterOperators: GridColDef['filterOperators'];
  getCellAggregationPosition: (id: GridRowId) => GridAggregationPosition | null;
}): AggregationWrappedColDefProperty<'filterOperators'> => {
  return filterOperators!.map((operator) => {
    return {
      ...operator,
      getApplyFilterFn: (filterItem, column) => {
        const originalFn = operator.getApplyFilterFn(filterItem, column);
        if (!originalFn) {
          return null;
        }

        return (params) => {
          if (getCellAggregationPosition(params.id)) {
            return true;
          }

          return originalFn(params);
        };
      },
    };
  });
};

export const wrapColumnWithAggregation = ({
  colDef,
  apiRef,
  aggregationItem,
  aggregationFunctions,
  aggregationPositionRef,
  isGroupAggregated,
}: {
  colDef: GridColDef;
  apiRef: React.MutableRefObject<GridApiPro>;
  aggregationItem: string;
  aggregationFunctions: Record<string, GridAggregationFunction>;
  aggregationPositionRef: React.MutableRefObject<GridAggregationPosition>;
  isGroupAggregated: DataGridProProcessedProps['isGroupAggregated'];
}): GridColDef => {
  const aggregationFunction = aggregationFunctions?.[aggregationItem];
  if (!aggregationFunction) {
    throw new Error(`MUI: No aggregation registered with the name ${aggregationItem}`);
  }

  if (!aggregationFunction.types.includes(colDef.type!)) {
    throw new Error(
      `MUI: The current aggregation function is not application to the type "${colDef.type}"`,
    );
  }

  const aggregationPosition = aggregationPositionRef.current;

  const getCellAggregationPosition = (id: GridRowId): GridAggregationPosition | null => {
    const isGroup = id.toString().startsWith('auto-generated-row-');

    if (isGroup && aggregationPosition === 'inline') {
      if (isGroupAggregated && !isGroupAggregated(apiRef.current.getRowNode(id))) {
        return null;
      }

      return 'inline';
    }

    const isFooter = id.toString().startsWith('auto-generated-group-footer-');
    if (isFooter && aggregationPosition === 'footer') {
      // We don't have to check `isGroupAggregated` because if it returns false, the footer is not created at all
      return 'footer';
    }

    return null;
  };

  return {
    ...colDef,
    valueGetter: getWrappedValueGetter({
      apiRef,
      valueGetter: colDef.valueGetter,
      aggregationFunction,
      getCellAggregationPosition,
    }),
    valueFormatter: getWrappedValueFormatter({
      valueFormatter: colDef.valueFormatter,
      aggregationFunction,
      getCellAggregationPosition,
    }),
    renderCell: getWrappedRenderCell({
      renderCell: colDef.renderCell,
      aggregationFunction,
      aggregationItem,
      getCellAggregationPosition,
    }),
    filterOperators: getWrappedFilterOperators({
      filterOperators: colDef.filterOperators,
      getCellAggregationPosition,
    }),
  };
};

export const unwrapColumnFromAggregation = ({ colDef }: { colDef: GridColDef }) => {
  let hasUnwrappedSomeProperty = false;

  const unwrappedColDef: GridColDef = { ...colDef };

  AGGREGATION_WRAPPABLE_METHODS.forEach((propertyName) => {
    const propertyValue = unwrappedColDef[propertyName];
    if (propertyValue == null) {
      return;
    }

    if (Array.isArray(propertyValue)) {
      let hasUnwrappedSomeSubProperty = false;
      const unwrappedPropertyValue: any = [];

      propertyValue.forEach((propertySubValue) => {
        if ((propertySubValue as any).isWrappedWithAggregation) {
          hasUnwrappedSomeSubProperty = true;
          unwrappedPropertyValue.push((propertySubValue as any).originalMethod);
        } else {
          unwrappedPropertyValue.push(propertySubValue);
        }

        if (hasUnwrappedSomeSubProperty) {
          hasUnwrappedSomeProperty = true;
          unwrappedColDef[propertyName] = unwrappedPropertyValue;
        }
      });
    }

    if ((propertyValue as any)?.isWrappedWithAggregation) {
      hasUnwrappedSomeProperty = true;
      unwrappedColDef[propertyName] = (propertyValue as any).originalMethod;
    }
  });

  if (!hasUnwrappedSomeProperty) {
    return colDef;
  }

  return unwrappedColDef;
};

export const getAvailableAggregationFunctions = ({
  aggregationFunctions,
  column,
}: {
  aggregationFunctions: Record<string, GridAggregationFunction>;
  column: GridColDef;
}) => {
  if (column.aggregable === false) {
    return [];
  }

  if (column.availableAggregationFunctions != null) {
    return column.availableAggregationFunctions;
  }

  return Object.keys(aggregationFunctions).filter((name) =>
    aggregationFunctions[name].types.includes(column.type!),
  );
};

export const mergeStateWithAggregationModel =
  (aggregationModel: GridAggregationModel) =>
  (state: GridStatePro): GridStatePro => ({
    ...state,
    aggregation: { ...state.aggregation, model: aggregationModel },
  });

export const sanitizeAggregationModel = (
  model: GridAggregationModel,
  columnsLookup: GridColumnRawLookup,
) => {
  const sanitizedModel: GridAggregationModel = {};

  Object.keys(model).forEach((field) => {
    if (columnsLookup[field] && columnsLookup[field].aggregable !== false) {
      sanitizedModel[field] = model[field];
    }
  });

  return model;
};

export const addFooterRows = ({
  groupingParams,
  isGroupAggregated,
}: {
  groupingParams: GridRowTreeCreationValue;
  isGroupAggregated: DataGridProProcessedProps['isGroupAggregated'];
}) => {
  const ids = [...groupingParams.ids];
  const idRowsLookup = { ...groupingParams.idRowsLookup };
  const tree = { ...groupingParams.tree };

  const addGroupFooter = (parentNode: GridRowTreeNodeConfig | null) => {
    const parentId = parentNode?.id ?? null;

    if (isGroupAggregated && !isGroupAggregated(parentNode)) {
      return;
    }

    const footerId =
      parentId == null
        ? `auto-generated-group-footer-root`
        : `auto-generated-group-footer-${parentId}`;

    ids.push(footerId);
    idRowsLookup[footerId] = {};
    tree[footerId] = {
      id: footerId,
      isAutoGenerated: true,
      parent: parentId,
      depth: parentNode ? parentNode.depth + 1 : 0,
      groupingKey: null,
      groupingField: null,
      position: 'footer',
    };

    if (parentId != null) {
      tree[parentId] = {
        ...tree[parentId],
        children: [...(tree[parentId].children ?? []), footerId],
      };
    }
  };

  addGroupFooter(null);

  // If the tree is flat, we don't need to loop through the rows
  if (groupingParams.treeDepth > 1) {
    groupingParams.ids.forEach((parentId) => {
      const parentNode = tree[parentId];
      if (parentNode.depth === groupingParams.treeDepth - 1) {
        return;
      }

      addGroupFooter(parentNode);
    });
  }

  return {
    ...groupingParams,
    ids,
    idRowsLookup,
    tree,
  };
};
