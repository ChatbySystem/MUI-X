import * as React from 'react';
import { GridColDef } from '@mui/x-data-grid';
import { GridApiPro } from '../../../models/gridApiPro';
import { GridAggregationFunction } from './gridAggregationInterfaces';

const sumAgg: GridAggregationFunction<number> = {
  apply: ({ values }) => {
    let sum = 0;
    for (let i = 0; i < values.length; i += 1) {
      sum += values[i];
    }

    return sum;
  },
  types: ['number'],
};

const minAgg: GridAggregationFunction<number> = {
  apply: ({ values }) => {
    if (values.length === 0) {
      return Number.NaN;
    }

    let min: number = +Infinity;
    for (let i = 0; i < values.length; i += 1) {
      const value = values[i];
      if (value < min) {
        min = value;
      }
    }

    return min;
  },
  types: ['number'],
};

const maxAgg: GridAggregationFunction<number> = {
  apply: ({ values }) => {
    if (values.length === 0) {
      return Number.NaN;
    }

    let max: number = -Infinity;
    for (let i = 0; i < values.length; i += 1) {
      const value = values[i];
      if (value > max) {
        max = value;
      }
    }

    return max;
  },
  types: ['number'],
};

const avgAgg: GridAggregationFunction<number> = {
  apply: (params) => {
    if (params.values.length === 0) {
      return Number.NaN;
    }

    const sum = sumAgg.apply(params);
    return sum / params.values.length;
  },
  types: ['number'],
};

const sizeAgg: GridAggregationFunction<number> = {
  apply: ({ values }) => {
    return values.length;
  },
  types: ['number'],
};

export const GRID_AGGREGATION_FUNCTIONS = {
  avg: avgAgg,
  min: minAgg,
  max: maxAgg,
  size: sizeAgg,
  sum: sumAgg,
};

export const wrapColumnWithAggregation = ({
  colDef,
  apiRef,
  aggregationFunctions,
  aggregationPositionRef,
}: {
  colDef: GridColDef;
  apiRef: React.MutableRefObject<GridApiPro>;
  aggregationFunctions: Record<string, GridAggregationFunction>;
  aggregationPositionRef: React.RefObject<'inline' | 'footer'>;
}) => {
  const { valueGetter, currentAggregation } = colDef;

  if (currentAggregation == null) {
    return colDef;
  }

  const aggregationFunction = aggregationFunctions?.[currentAggregation];

  if (!aggregationFunction) {
    throw new Error(`MUI: No aggregation registered with the name ${currentAggregation}`);
  }

  if (!aggregationFunction.types.includes(colDef.type!)) {
    throw new Error(
      `MUI: The current aggregation function is not application to the type "${colDef.type}"`,
    );
  }

  const wrappedValueGetter: GridColDef['valueGetter'] = (params) => {
    if (params.rowNode.isAutoGenerated) {
      const isGroup = params.id.toString().startsWith('auto-generated-row-');
      const isFooter = params.id.toString().startsWith('auto-generated-group-footer-');

      if (
        (isGroup && aggregationPositionRef.current === 'inline') ||
        (isFooter && aggregationPositionRef.current === 'footer')
      ) {
        const rowIds = isFooter
          ? apiRef.current.getRowNode(params.rowNode.parent!)?.children
          : params.rowNode.children;
        const validRowIds = (rowIds ?? []).filter(
          (rowId) => !apiRef.current.getRowNode(rowId)?.isAutoGenerated,
        );

        return aggregationFunction.apply({
          values: validRowIds.map((rowId) => apiRef.current.getCellValue(rowId, params.field)),
        });
      }
    }

    if (valueGetter) {
      return valueGetter(params);
    }

    return params.row[params.field];
  };

  return {
    ...colDef,
    valueGetter: wrappedValueGetter,
  };
};

export const getAvailableAggregationFunctions = ({
  aggregationFunctions,
  column,
}: {
  aggregationFunctions: Record<string, GridAggregationFunction>;
  column: GridColDef;
}) => {
  if (column.aggregable === false) {
    return [];
  }

  if (column.availableAggregationFunctions != null) {
    return column.availableAggregationFunctions;
  } else {
    return Object.keys(aggregationFunctions).filter((name) =>
      aggregationFunctions[name].types.includes(column.type!),
    );
  }
};
