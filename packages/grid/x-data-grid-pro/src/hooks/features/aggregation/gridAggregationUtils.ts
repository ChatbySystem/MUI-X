import * as React from 'react';
import { GridColDef } from '@mui/x-data-grid';
import { GridApiPro } from '../../../models/gridApiPro';
import { GridAggregationFunction } from './gridAggregationInterfaces';

const sumAgg: GridAggregationFunction<number> = {
  apply: ({ values }) => {
    let sum = 0;
    for (let i = 0; i < values.length; i += 1) {
      sum += values[i];
    }

    return sum;
  },
  types: ['number'],
};

const minAgg: GridAggregationFunction<number> = {
  apply: ({ values }) => {
    if (values.length === 0) {
      return Number.NaN;
    }

    let min: number = +Infinity;
    for (let i = 0; i < values.length; i += 1) {
      const value = values[i];
      if (value < min) {
        min = value;
      }
    }

    return min;
  },
  types: ['number'],
};

const maxAgg: GridAggregationFunction<number> = {
  apply: ({ values }) => {
    if (values.length === 0) {
      return Number.NaN;
    }

    let max: number = -Infinity;
    for (let i = 0; i < values.length; i += 1) {
      const value = values[i];
      if (value > max) {
        max = value;
      }
    }

    return max;
  },
  types: ['number'],
};

const avgAgg: GridAggregationFunction<number> = {
  apply: (params) => {
    if (params.values.length === 0) {
      return Number.NaN;
    }

    const sum = sumAgg.apply(params);
    return sum / params.values.length;
  },
  types: ['number'],
};

const sizeAgg: GridAggregationFunction<number> = {
  apply: ({ values }) => {
    return values.length;
  },
  types: ['number'],
};

export const GRID_AGGREGATION_FUNCTIONS = {
  avg: avgAgg,
  min: minAgg,
  max: maxAgg,
  size: sizeAgg,
  sum: sumAgg,
};

export const wrapColumnWithAggregation = ({
  colDef,
  apiRef,
  aggregationFunctions,
}: {
  colDef: GridColDef;
  apiRef: React.MutableRefObject<GridApiPro>;
  aggregationFunctions: Record<string, GridAggregationFunction>;
}) => {
  const { valueGetter, currentAggregation } = colDef;

  if (currentAggregation != null) {
    const aggregationFunction = aggregationFunctions?.[currentAggregation];

    if (!aggregationFunction) {
      throw new Error(`MUI: No aggregation registered with the name ${currentAggregation}`);
    }

    if (!aggregationFunction.types.includes(colDef.type!)) {
      throw new Error(
        `MUI: The current aggregation function is not application to the type "${colDef.type}"`,
      );
    }

    colDef.valueGetter = (params) => {
      if (!params.rowNode.isAutoGenerated) {
        if (valueGetter) {
          return valueGetter(params);
        }

        return params.row[params.field];
      }

      return aggregationFunction.apply({
        values: (params.rowNode.children ?? []).map((id) =>
          apiRef.current.getCellValue(id, params.field),
        ),
      });
    };
  }
};
