import * as React from 'react';
import {GridColDef, GridRowId, gridRowIdsSelector} from '@mui/x-data-grid';
import { GridColumnRawLookup } from '@mui/x-data-grid/internals';
import { GridApiPro } from '../../../models/gridApiPro';
import {
  GridAggregationFunction,
  GridAggregationItem,
  GridAggregationModel,
} from './gridAggregationInterfaces';
import { GridStatePro } from '../../../models/gridStatePro';

const sumAgg: GridAggregationFunction<number> = {
  apply: ({ values }) => {
    let sum = 0;
    for (let i = 0; i < values.length; i += 1) {
      sum += values[i];
    }

    return sum;
  },
  types: ['number'],
};

const minAgg: GridAggregationFunction<number> = {
  apply: ({ values }) => {
    if (values.length === 0) {
      return Number.NaN;
    }

    let min: number = +Infinity;
    for (let i = 0; i < values.length; i += 1) {
      const value = values[i];
      if (value < min) {
        min = value;
      }
    }

    return min;
  },
  types: ['number'],
};

const maxAgg: GridAggregationFunction<number> = {
  apply: ({ values }) => {
    if (values.length === 0) {
      return Number.NaN;
    }

    let max: number = -Infinity;
    for (let i = 0; i < values.length; i += 1) {
      const value = values[i];
      if (value > max) {
        max = value;
      }
    }

    return max;
  },
  types: ['number'],
};

const avgAgg: GridAggregationFunction<number> = {
  apply: (params) => {
    if (params.values.length === 0) {
      return Number.NaN;
    }

    const sum = sumAgg.apply(params);
    return sum / params.values.length;
  },
  types: ['number'],
};

const sizeAgg: GridAggregationFunction<number> = {
  apply: ({ values }) => {
    return values.length;
  },
  types: ['number'],
};

export const GRID_AGGREGATION_FUNCTIONS = {
  avg: avgAgg,
  min: minAgg,
  max: maxAgg,
  size: sizeAgg,
  sum: sumAgg,
};

export const wrapColumnWithAggregation = ({
  colDef,
  apiRef,
  currentAggregation,
  aggregationFunctions,
  aggregationPositionRef,
}: {
  colDef: GridColDef;
  apiRef: React.MutableRefObject<GridApiPro>;
  currentAggregation: GridAggregationItem;
  aggregationFunctions: Record<string, GridAggregationFunction>;
  aggregationPositionRef: React.RefObject<'inline' | 'footer'>;
}) => {
  const aggregationFunction = aggregationFunctions?.[currentAggregation.method];

  if (!aggregationFunction) {
    throw new Error(`MUI: No aggregation registered with the name ${currentAggregation}`);
  }

  if (!aggregationFunction.types.includes(colDef.type!)) {
    throw new Error(
      `MUI: The current aggregation function is not application to the type "${colDef.type}"`,
    );
  }

  const wrappedValueGetter: GridColDef['valueGetter'] = (params) => {
    if (params.rowNode.isAutoGenerated) {
      const isGroup = params.id.toString().startsWith('auto-generated-row-');
      const isFooter = params.id.toString().startsWith('auto-generated-group-footer-');

      if (
        (isGroup && aggregationPositionRef.current === 'inline') ||
        (isFooter && aggregationPositionRef.current === 'footer')
      ) {
        let rowIds: GridRowId[] | undefined
        if (isFooter) {
          if (params.rowNode.parent == null) {
            rowIds = gridRowIdsSelector(apiRef)
          } else {
            rowIds = apiRef.current.getRowNode(params.rowNode.parent)?.children
          }
        } else {
          rowIds = params.rowNode.children
        }

        const validRowIds = (rowIds ?? []).filter(
          (rowId) => !apiRef.current.getRowNode(rowId)?.isAutoGenerated,
        );

        return aggregationFunction.apply({
          values: validRowIds.map((rowId) => apiRef.current.getCellValue(rowId, params.field)),
        });
      }
    }

    if (colDef.valueGetter) {
      return colDef.valueGetter(params);
    }

    return params.row[params.field];
  };

  return {
    ...colDef,
    valueGetter: wrappedValueGetter,
  };
};

export const unwrapColumnFromAggregation = ({
  colDef,
  colDefBeforePreProcessing,
}: {
  colDef: GridColDef;
  colDefBeforePreProcessing: GridColDef;
}) => {
  return {
    ...colDef,
    valueGetter: colDefBeforePreProcessing.valueGetter,
  };
};

export const getAvailableAggregationFunctions = ({
  aggregationFunctions,
  column,
}: {
  aggregationFunctions: Record<string, GridAggregationFunction>;
  column: GridColDef;
}) => {
  if (column.aggregable === false) {
    return [];
  }

  if (column.availableAggregationFunctions != null) {
    return column.availableAggregationFunctions;
  } else {
    return Object.keys(aggregationFunctions).filter((name) =>
      aggregationFunctions[name].types.includes(column.type!),
    );
  }
};

export const mergeStateWithAggregationModel =
  (aggregationModel: GridAggregationModel) =>
  (state: GridStatePro): GridStatePro => ({
    ...state,
    aggregation: { ...state.aggregation, model: aggregationModel },
  });

export const sanitizeAggregationModel = (
  model: GridAggregationModel,
  columnsLookup: GridColumnRawLookup,
) => {
  const sanitizedModel: GridAggregationModel = {};

  Object.keys(model).forEach((field) => {
    if (columnsLookup[field].aggregable !== false) {
      sanitizedModel[field] = model[field];
    }
  });

  return model;
};
