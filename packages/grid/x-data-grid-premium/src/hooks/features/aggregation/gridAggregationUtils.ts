import * as React from 'react';
import {
  GridColDef,
  gridColumnLookupSelector,
  GridRowId,
  GridRowTreeConfig,
  GridRowTreeNodeConfig,
} from '@mui/x-data-grid-pro';
import { GridColumnRawLookup, GridRowTreeCreationValue } from '@mui/x-data-grid-pro/internals';
import { GridAggregationFunction, GridAggregationModel } from './gridAggregationInterfaces';
import { GridStatePremium } from '../../../models/gridStatePremium';
import { DataGridPremiumProcessedProps } from '../../../models/dataGridPremiumProps';
import { GridApiPremium } from '../../../models/gridApiPremium';
import { gridAggregationSanitizedModelSelector } from './gridAggregationSelectors';

export const getNonAutoGeneratedDescendants = (tree: GridRowTreeConfig, parentId: GridRowId) => {
  const children = tree[parentId].children;
  if (children == null) {
    return [];
  }

  const validDescendants: GridRowId[] = [];
  for (let i = 0; i < children.length; i += 1) {
    const child = children[i];
    const childNode = tree[child];
    if (!childNode.isAutoGenerated) {
      validDescendants.push(child);
    }
    validDescendants.push(...getNonAutoGeneratedDescendants(tree, childNode.id));
  }

  return validDescendants;
};

export const canColumnHaveAggregationFunction = ({
  column,
  aggregationFunctionName,
  aggregationFunction,
}: {
  column: GridColDef;
  aggregationFunctionName: string;
  aggregationFunction: GridAggregationFunction | undefined;
}): boolean => {
  if (!aggregationFunction) {
    return false;
  }

  if (!column.aggregable) {
    return false;
  }

  if (column.availableAggregationFunctions != null) {
    return column.availableAggregationFunctions.includes(aggregationFunctionName);
  }

  if (!aggregationFunction.types) {
    return true;
  }

  return aggregationFunction.types.includes(column.type!);
};

export const getAvailableAggregationFunctions = ({
  aggregationFunctions,
  column,
}: {
  aggregationFunctions: Record<string, GridAggregationFunction>;
  column: GridColDef;
}) =>
  Object.keys(aggregationFunctions).filter((aggregationFunctionName) =>
    canColumnHaveAggregationFunction({
      column,
      aggregationFunctionName,
      aggregationFunction: aggregationFunctions[aggregationFunctionName],
    }),
  );

export const mergeStateWithAggregationModel =
  (aggregationModel: GridAggregationModel) =>
  (state: GridStatePremium): GridStatePremium => ({
    ...state,
    aggregation: { ...state.aggregation, model: aggregationModel },
  });

export const sanitizeAggregationModel = (
  model: GridAggregationModel,
  columnsLookup: GridColumnRawLookup,
) => {
  const sanitizedModel: GridAggregationModel = {};

  Object.keys(model).forEach((field) => {
    if (columnsLookup[field] && columnsLookup[field].aggregable !== false) {
      sanitizedModel[field] = model[field];
    }
  });

  return model;
};

export const addFooterRows = ({
  apiRef,
  groupingParams,
  isGroupAggregated,
  aggregationFunctions,
}: {
  apiRef: React.MutableRefObject<GridApiPremium>;
  groupingParams: GridRowTreeCreationValue;
  isGroupAggregated: DataGridPremiumProcessedProps['isGroupAggregated'];
  aggregationFunctions: Record<string, GridAggregationFunction>;
}) => {
  const aggregationModel = gridAggregationSanitizedModelSelector(apiRef);
  const columnsLookup = gridColumnLookupSelector(apiRef);

  const hasValidAggregationRule = Object.entries(aggregationModel).some(
    ([field, aggregationFunctionName]) =>
      canColumnHaveAggregationFunction({
        column: columnsLookup[field],
        aggregationFunctionName,
        aggregationFunction: aggregationFunctions[aggregationFunctionName],
      }),
  );

  if (!hasValidAggregationRule) {
    return groupingParams;
  }

  const ids = [...groupingParams.ids];
  const idRowsLookup = { ...groupingParams.idRowsLookup };
  const tree = { ...groupingParams.tree };

  const addGroupFooter = (parentNode: GridRowTreeNodeConfig | null) => {
    const parentId = parentNode?.id ?? null;

    if (isGroupAggregated && !isGroupAggregated(parentNode)) {
      return;
    }

    const footerId =
      parentId == null
        ? `auto-generated-group-footer-root`
        : `auto-generated-group-footer-${parentId}`;

    ids.push(footerId);
    idRowsLookup[footerId] = {};
    tree[footerId] = {
      id: footerId,
      isAutoGenerated: true,
      parent: parentId,
      depth: parentNode ? parentNode.depth + 1 : 0,
      groupingKey: null,
      groupingField: null,
      position: 'footer',
    };

    if (parentId != null) {
      tree[parentId] = {
        ...tree[parentId],
        children: [...(tree[parentId].children ?? []), footerId],
      };
    }
  };

  addGroupFooter(null);

  // If the tree is flat, we don't need to loop through the rows
  if (groupingParams.treeDepth > 1) {
    groupingParams.ids.forEach((parentId) => {
      const parentNode = tree[parentId];
      if (parentNode.depth === groupingParams.treeDepth - 1) {
        return;
      }

      addGroupFooter(parentNode);
    });
  }

  return {
    ...groupingParams,
    ids,
    idRowsLookup,
    tree,
  };
};
