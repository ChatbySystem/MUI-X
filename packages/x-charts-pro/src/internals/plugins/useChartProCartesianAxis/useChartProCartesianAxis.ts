'use client';
import * as React from 'react';
import useEnhancedEffect from '@mui/utils/useEnhancedEffect';
import {
  computeAxisValue,
  selectorChartDrawingArea,
  selectorChartSeriesState,
  ChartPlugin,
  useSelector,
  defaultizeAxis,
  AxisId,
} from '@mui/x-charts/internals';
import { blueberryTwilightPalette } from '@mui/x-charts/colorPalettes';
import {
  DefaultizedZoomOptions,
  UseChartProCartesianAxisSignature,
  ZoomData,
} from './useChartProCartesianAxis.types';
import { defaultizeZoom } from './defaultizeZoom';
import { createZoomMap } from './useChartProCartesianAxis.utils';

export const useChartProCartesianAxis: ChartPlugin<UseChartProCartesianAxisSignature> = ({
  params,
  store,
  models,
}) => {
  useEnhancedEffect(() => {
    store.update((prevState) => ({
      ...prevState,
      zoom: {
        ...prevState.zoom,
        zoomMap: createZoomMap(models.zoom.value),
      },
    }));
  }, [store, models.zoom.value]);

  const { xAxis, yAxis, dataset } = params;


  // The effect do not track any value defined synchronously during the 1st render by hooks called after `useChartProCartesianAxis`
  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one
  const isFirstRender = React.useRef(true);
  React.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }

    const defaultizedXAxis = defaultizeAxis(xAxis, dataset, 'x');
    const defaultizedYAxis = defaultizeAxis(yAxis, dataset, 'y');
    store.update((prev) => {
      return {
        ...prev,
        cartesianAxis: {
          x: defaultizedXAxis,
          y: defaultizedYAxis,
        },
      };
    });
  }, [xAxis, yAxis, dataset, store]);

  return {};
};

useChartProCartesianAxis.params = {
  xAxis: true,
  yAxis: true,
  dataset: true,
  zoom: true,
  onZoomChange: true,
};

useChartProCartesianAxis.getDefaultizedParams = ({ params }) => ({
  ...params,
  colors: params.colors ?? blueberryTwilightPalette,
  theme: params.theme ?? 'light',
});

const DEFAULT_ZOOMS: ZoomData[] = [];

useChartProCartesianAxis.models = {
  zoom: {
    getDefaultValue: () => DEFAULT_ZOOMS,
  },
};

useChartProCartesianAxis.getInitialState = (params) => {
  const defaultizedXAxis = defaultizeAxis(params.xAxis, params.dataset, 'x');
  const defaultizedYAxis = defaultizeAxis(params.yAxis, params.dataset, 'y');

  const options = {
    ...defaultizedXAxis.reduce<Record<AxisId, DefaultizedZoomOptions>>((acc, v) => {
      const { zoom, id: axisId } = v;
      const defaultizedZoom = defaultizeZoom(zoom, axisId, 'x');
      if (defaultizedZoom) {
        acc[axisId] = defaultizedZoom;
      }
      return acc;
    }, {}),
    ...defaultizedYAxis.reduce<Record<AxisId, DefaultizedZoomOptions>>((acc, v) => {
      const { zoom, id: axisId } = v;
      const defaultizedZoom = defaultizeZoom(zoom, axisId, 'y');
      if (defaultizedZoom) {
        acc[axisId] = defaultizedZoom;
      }
      return acc;
    }, {}),
  };

  return {
    zoom: {
      options,
      zoomMap: createZoomMap(params.zoom === undefined ? [] : params.zoom),
      isInteracting: false,
    },
    cartesianAxis: {
      x: defaultizedXAxis,
      y: defaultizedYAxis,
    },
  };
};
